%{
\\ mips.gr	mips BURG grammar
\\
\\ Copyright (C) 1995-96 Martin Anton Ertl, Christian Pirker
\\
\\ This file is part of RAFTS.
\\
\\	RAFTS is free software you can redistribute it and/or
\\	modify it under the terms of the GNU General Public License
\\	as published by the Free Software Foundation; either version 2
\\	of the License, or (at your option) any later version.
\\
\\	This program is distributed in the hope that it will be useful,
\\	but WITHOUT ANY WARRANTY; without even the implied warranty of
\\	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
\\	GNU General Public License for more details.
\\
\\	You should have received a copy of the GNU General Public License
\\	along with this program; if not, write to the Free Software
\\	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

: node_op@ ( node_addr -- op )
  node_op @ ;
: node_op! ( op node_addr -- )
  node_op ! ;

: node_slabel@ ( node_addr -- slabel )
  node_slabel @ ;
: node_slabel! ( slabel node_addr -- )
  node_slabel ! ;

: node_left@ ( node_addr -- left )
  node_left @ ;
: node_left! ( left node_addr -- )
  node_left ! ;

: node_right@ ( node_addr -- right )
  node_right @ ;
: node_right! ( right node_addr -- )
  node_right ! ;

\' node_op alias OP_LABEL
\' node_op@ alias OP_LABEL@
\' node_op! alias OP_LABEL!
\' node_slabel alias STATE_LABEL
\' node_slabel@ alias STATE_LABEL@
\' node_slabel! alias STATE_LABEL!
\' node_left alias LEFT_CHILD
\' node_left@ alias LEFT_CHILD@
\' node_left! alias LEFT_CHILD!
\' node_right alias RIGHT_CHILD
\' node_right@ alias RIGHT_CHILD@
\' node_right! alias RIGHT_CHILD!

: val ( node_addr -- node_addr )
  ;
: lval ( node_addr -- node_addr )
  LEFT_CHILD ;
: llval ( node_addr -- node_addr )
  LEFT_CHILD@ LEFT_CHILD ;
: lrval ( node_addr -- node_addr )
  LEFT_CHILD@ RIGHT_CHILD ; 
: rval ( node_addr -- node_addr )
  RIGHT_CHILD ;
: rlval ( node_addr -- node_addr )
  RIGHT_CHILD@ LEFT_CHILD ; 
: rrval ( node_addr -- node_addr ) 
  RIGHT_CHILD@ RIGHT_CHILD ;

: val@ ( node_addr -- node_addr )
  val @ ;
: lval@ ( node_addr -- node_addr )
  lval @ ;
: llval@ ( node_addr -- node_addr )
  llval @ ;
: lrval@ ( node_addr -- node_addr )
  lrval @ ;
: rval@ ( node_addr -- node_addr )
  rval @ ;
: rlval@ ( node_addr -- node_addr )
  rlval @ ;
: rrval@ ( node_addr -- node_addr ) 
  rrval @ ;

\' .\" alias burm_PANIC\" immediate

0 constant none
1 constant unary
2 constant binary

%}

%start stmt

%term I_LIT=1

/* unary operators	*/
%term I_INVERT=2
%term I_NEGATE=3

/* binary operators	*/
%term I_PLUS=4
%term I_MINUS=5
%term I_TIMES=6
%term I_SLASH=7
%term I_MOD=8
%term I_AND=9 I_OR=10 I_XOR=11
%term I_LSHIFT=12 I_RSHIFT=13 I_SRSHIFT=14

/* fetch and store	*/
%term I_CFETCH=15 I_FETCH=16
%term I_CSTORE=17 I_STORE=18

/* compare		*/
%term I_EQUALS=19 I_LESS=20 I_ULESS=21
%term I_0BRANCH=22 I_BRANCH=23

%term I_REG=24

%term I_LITS=30 

/* %term I_LITF=40 I_FNEGATE=41 I_FPLUS=42 I_FMINUS=43 I_FTIMES=44  I_FSLASH=45
   %term I_FFETCH=46  I_FSTORE=47
*/

%term NOP=50

/*
addr: I_PLUS(cons, reg)		#0#	>r swap dup node_val @ r@ node_val ! [\'] asm_addr r> inst_ok
reg:  I_PLUS(cons, reg)		#1#	>r swap [\'] asm_addi r> inst_ok
reg:  I_AND(cons, reg)		#1#	>r swap [\'] asm_andi r> inst_ok
reg:  I_MINUS(reg, cons)		#1#	>r [\'] asm_addi r@ rval@ node_val @ negate r@ rval@ node_val ! r> inst_ok
reg:  I_OR(cons, reg)		#1#	>r swap [\'] asm_ori r> inst_ok
reg:  I_XOR(cons, reg)		#1#	>r swap [\'] asm_xori r> inst_ok
*/
%%

stmt: reg			#0#	2drop
addr: I_PLUS(reg, cons)		#0#	>r dup node_val @ r@ node_val ! [\'] asm_addr r> inst_ok

reg:  I_REG			#0#	
cons: I_LITS			#0#	dup inst_done
con:  I_LIT			#0#	dup inst_done
reg:  cons			#1#	node_dup >r r@ inst_notdone NIL [\'] asm_lit r> inst_ok
reg:  con			#1#	node_dup >r r@ inst_notdone NIL [\'] asm_lit r> inst_ok

reg:  I_CFETCH(addr)		#1#	>r r@ inst_notdone NIL [\'] asm_fetchc r> inst_ok
reg:  I_CFETCH(reg)		#1#	>r r@ inst_notdone NIL [\'] asm_fetchregc r> inst_ok
reg:  I_FETCH(addr)		#1#	>r r@ inst_notdone NIL [\'] asm_fetchi r> inst_ok
reg:  I_FETCH(reg)		#1#	>r r@ inst_notdone NIL [\'] asm_fetchregi r> inst_ok
stmt: I_CSTORE(reg, addr)	#1#	>r 0 r@ node_reg ! [\'] asm_storec r> inst_ok drop
stmt: I_CSTORE(reg, reg)	#1#	>r 0 r@ node_reg ! [\'] asm_storeregc r> inst_ok drop
stmt: I_STORE(reg, addr)	#1#	>r 0 r@ node_reg ! [\'] asm_storei r> inst_ok drop
stmt: I_STORE(reg, reg)		#1#	>r 0 r@ node_reg ! [\'] asm_storeregi r> inst_ok drop

reg:  I_PLUS(reg, reg)		#1#	>r [\'] asm_add r> inst_ok
reg:  I_PLUS(reg, cons)		#1#	>r [\'] asm_addi r> inst_ok
reg:  I_MINUS(reg, reg)		#1#	>r [\'] asm_sub r> inst_ok
reg: I_TIMES(reg, reg)		#1#	>r [\'] asm_mul r> inst_ok
reg: I_SLASH(reg, reg)		#1#	>r [\'] asm_div r> inst_ok
reg: I_MOD(reg, reg)		#1#	>r [\'] asm_mod r> inst_ok
reg:  I_NEGATE(reg)		#1#	>r NIL [\'] asm_neg r> inst_ok

reg:  I_AND(reg, reg)		#1#	>r [\'] asm_and r> inst_ok
reg:  I_AND(reg, cons)		#1#	>r [\'] asm_andi r> inst_ok
reg:  I_OR(reg, reg)		#1#	>r [\'] asm_or r> inst_ok
reg:  I_OR(reg, cons)		#1#	>r [\'] asm_ori r> inst_ok
reg:  I_XOR(reg, reg)		#1#	>r [\'] asm_xor r> inst_ok
reg:  I_XOR(reg, cons)		#1#	>r [\'] asm_xori r> inst_ok
reg:  I_INVERT(reg)		#1#	>r NIL [\'] asm_not r> inst_ok
reg:  I_LSHIFT(reg, reg)	#1#	>r [\'] asm_lsh r> inst_ok
reg:  I_LSHIFT(reg, cons)	#1#	>r [\'] asm_lshi r> inst_ok
reg:  I_RSHIFT(reg, reg)	#1#	>r [\'] asm_rshu r> inst_ok
reg:  I_SRSHIFT(reg, reg)	#1#	>r [\'] asm_rsh r> inst_ok
reg:  I_RSHIFT(reg, cons)	#1#	>r [\'] asm_rshui r> inst_ok
reg:  I_SRSHIFT(reg, cons)	#1#	>r [\'] asm_rshi r> inst_ok

flag:  I_EQUALS(reg, reg)	#2#	>r [\'] asm_seq r> inst_ok
reg:  I_LESS(reg, reg)		#1#	>r [\'] asm_slt r> inst_ok
reg:  I_LESS(reg, cons)		#1#	>r [\'] asm_slti r> inst_ok
reg:  I_ULESS(reg, reg)		#1#	>r [\'] asm_sltu r> inst_ok
reg:  I_ULESS(reg, cons)	#1#	>r [\'] asm_sltui r> inst_ok
stmt: I_0BRANCH(reg)		#1#	>r NIL [\'] asm_0branch 0 r@ node_cost ! r> inst_ok drop
stmt: I_BRANCH			#1#	>r NIL NIL [\'] asm_branch 0 r@ node_cost ! r> inst_ok drop
stmt: NOP
%%
