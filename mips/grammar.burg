%{
\\ mips.gr	mips BURG grammar
\\
\\ Copyright (C) 1995-96 Martin Anton Ertl, Christian Pirker
\\
\\ This file is part of RAFTS.
\\
\\	RAFTS is free software you can redistribute it and/or
\\	modify it under the terms of the GNU General Public License
\\	as published by the Free Software Foundation; either version 2
\\	of the License, or (at your option) any later version.
\\
\\	This program is distributed in the hope that it will be useful,
\\	but WITHOUT ANY WARRANTY; without even the implied warranty of
\\	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
\\	GNU General Public License for more details.
\\
\\	You should have received a copy of the GNU General Public License
\\	along with this program; if not, write to the Free Software
\\	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

: node_op@ ( node_addr -- op )
  node_op @ ;
: node_op! ( op node_addr -- )
  node_op ! ;

: node_slabel@ ( node_addr -- slabel )
  node_slabel @ ;
: node_slabel! ( slabel node_addr -- )
  node_slabel ! ;

: node_left@ ( node_addr -- left )
  node_left @ ;
: node_left! ( left node_addr -- )
  node_left ! ;

: node_right@ ( node_addr -- right )
  node_right @ ;
: node_right! ( right node_addr -- )
  node_right ! ;

\' node_op alias OP_LABEL
\' node_op@ alias OP_LABEL@
\' node_op! alias OP_LABEL!
\' node_slabel alias STATE_LABEL
\' node_slabel@ alias STATE_LABEL@
\' node_slabel! alias STATE_LABEL!
\' node_left alias LEFT_CHILD
\' node_left@ alias LEFT_CHILD@
\' node_left! alias LEFT_CHILD!
\' node_right alias RIGHT_CHILD
\' node_right@ alias RIGHT_CHILD@
\' node_right! alias RIGHT_CHILD!

: val ( node_addr -- node_addr )
  ;
: lval ( node_addr -- node_addr )
  LEFT_CHILD ;
: llval ( node_addr -- node_addr )
  LEFT_CHILD@ LEFT_CHILD ;
: lrval ( node_addr -- node_addr )
  LEFT_CHILD@ RIGHT_CHILD ; 
: rval ( node_addr -- node_addr )
  RIGHT_CHILD ;
: rlval ( node_addr -- node_addr )
  RIGHT_CHILD@ LEFT_CHILD ; 
: rrval ( node_addr -- node_addr ) 
  RIGHT_CHILD@ RIGHT_CHILD ;

: val@ ( node_addr -- node_addr )
  val @ ;
: lval@ ( node_addr -- node_addr )
  lval @ ;
: llval@ ( node_addr -- node_addr )
  llval @ ;
: lrval@ ( node_addr -- node_addr )
  lrval @ ;
: rval@ ( node_addr -- node_addr )
  rval @ ;
: rlval@ ( node_addr -- node_addr )
  rlval @ ;
: rrval@ ( node_addr -- node_addr ) 
  rrval @ ;

\' .\" alias burm_PANIC\" immediate

0 constant none
1 constant unary
2 constant binary

: bin-inst ( left_node right_node node_addr asm_xt -- node_addr )
    swap inst_ok ;

: un-inst ( left-node node-addr asm-xt -- node-addr )
    NIL swap rot inst_ok ;

: 0branch-inst ( left-node node-addr asm-xt -- )
    swap >r NIL swap 0 r@ node_cost ! r> inst_ok drop ;

: branch-inst ( node-addr asm-xt -- )
    NIL -rot 0branch-inst ;

: store-inst ( left_node right_node node_addr asm_xt -- )
    swap >r 0 r@ node_reg ! r> inst_ok drop ;

: load-inst ( left-node node-addr asm-xt -- node-addr )
    swap >r NIL swap r@ inst_notdone r> inst_ok ;


%}

%start stmt

%term I_LIT=1

/* unary operators	*/
%term I_INVERT=2
%term I_NEGATE=3

/* binary operators	*/
%term I_PLUS=4
%term I_MINUS=5
%term I_TIMES=6
%term I_SLASH=7
%term I_MOD=8
%term I_AND=9 I_OR=10 I_XOR=11
%term I_LSHIFT=12 I_RSHIFT=13 I_SRSHIFT=14

/* fetch and store	*/
%term I_CFETCH=15 I_FETCH=16
%term I_CSTORE=17 I_STORE=18

/* compare		*/
%term I_EQUALS=19 I_LESS=20 I_ULESS=21
%term I_0BRANCH=22 I_BRANCH=23

%term I_REG=24

%term I_LITS=30 

/* %term I_LITF=40 I_FNEGATE=41 I_FPLUS=42 I_FMINUS=43 I_FTIMES=44  I_FSLASH=45
   %term I_FFETCH=46  I_FSTORE=47
*/

%term NOP=50

%%

stmt: reg			#0#	2drop
addr: I_PLUS(reg, cons)		#0#	>r dup node_val @ r@ node_val ! [\'] asm_addr r> inst_ok

reg:  I_REG			#0#	
cons: I_LITS			#0#	dup inst_done
con:  I_LIT			#0#	dup inst_done
reg:  cons			#1#	node_dup >r r@ inst_notdone NIL [\'] asm_lit r> inst_ok
reg:  con			#1#	node_dup >r r@ inst_notdone NIL [\'] asm_lit r> inst_ok

reg:  I_CFETCH(addr)		#1#	[\'] asm_fetchc load-inst
reg:  I_CFETCH(reg)		#1#	[\'] asm_fetchregc load-inst
reg:  I_FETCH(addr)		#1#	[\'] asm_fetchi load-inst
reg:  I_FETCH(reg)		#1#	[\'] asm_fetchregi load-inst
stmt: I_CSTORE(reg, addr)	#1#	[\'] asm_storec store-inst
stmt: I_CSTORE(reg, reg)	#1#	[\'] asm_storeregc store-inst
stmt: I_STORE(reg, addr)	#1#	[\'] asm_storei store-inst
stmt: I_STORE(reg, reg)		#1#	[\'] asm_storeregi store-inst

reg:  I_PLUS(reg, reg)		#1#	[\'] asm_add bin-inst
reg:  I_PLUS(reg, cons)		#1#	[\'] asm_addi bin-inst
reg:  I_MINUS(reg, reg)		#1#	[\'] asm_sub bin-inst
reg:  I_TIMES(reg, reg)		#1#	[\'] asm_mul bin-inst
reg:  I_SLASH(reg, reg)		#1#	[\'] asm_div bin-inst
reg:  I_MOD(reg, reg)		#1#	[\'] asm_mod bin-inst
reg:  I_NEGATE(reg)		#1#	[\'] asm_neg un-inst

reg:  I_AND(reg, reg)		#1#	[\'] asm_and bin-inst
reg:  I_AND(reg, cons)		#1#	[\'] asm_andi bin-inst
reg:  I_OR(reg, reg)		#1#	[\'] asm_or bin-inst
reg:  I_OR(reg, cons)		#1#	[\'] asm_ori bin-inst
reg:  I_XOR(reg, reg)		#1#	[\'] asm_xor bin-inst
reg:  I_XOR(reg, cons)		#1#	[\'] asm_xori bin-inst
reg:  I_INVERT(reg)		#1#	[\'] asm_not un-inst
reg:  I_LSHIFT(reg, reg)	#1#	[\'] asm_lsh bin-inst
reg:  I_LSHIFT(reg, cons)	#1#	[\'] asm_lshi bin-inst
reg:  I_RSHIFT(reg, reg)	#1#	[\'] asm_rshu bin-inst
reg:  I_SRSHIFT(reg, reg)	#1#	[\'] asm_rsh bin-inst
reg:  I_RSHIFT(reg, cons)	#1#	[\'] asm_rshui bin-inst
reg:  I_SRSHIFT(reg, cons)	#1#	[\'] asm_rshi bin-inst

flag:  I_EQUALS(reg, reg)	#2#	[\'] asm_seq bin-inst
reg:  I_LESS(reg, reg)		#1#	[\'] asm_slt bin-inst
reg:  I_LESS(reg, cons)		#1#	[\'] asm_slti bin-inst
reg:  I_ULESS(reg, reg)		#1#	[\'] asm_sltu bin-inst
reg:  I_ULESS(reg, cons)	#1#	[\'] asm_sltui bin-inst
stmt: I_0BRANCH(reg)		#1#	[\'] asm_0branch 0branch-inst
stmt: I_BRANCH			#1#	[\'] asm_branch branch-inst
%%
: burm_reduce ( goal node-addr -- )
  ( ." printReduce1" hex.s cr )
  tuck burm_STATE_LABEL@ swap burm_rule
  dup 0= if
    nip nip
    burm_assert" no cover" cr else
    2dup 2>r
    dup burm_nts@ >r		( R: goal node_addr nts-addr )
    depth >r burm_kids depth r> - 2 +
    r>
    swap case
      0 of
        endof
      1 of
        swap >r endof
      2 of
        rot >r swap >r endof endcase
    >r
    begin
      r> dup @ dup 0<> while
      r> rot cell+ >r
      recurse
      repeat
    2drop
    2r>
    [burm_reduce] @ execute
    endif
  ( ." printReduce2" hex.s cr )
  ;
