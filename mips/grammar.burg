%{
\\ mips.gr	mips BURG grammar
\\
\\ Copyright (C) 1995-96 Martin Anton Ertl, Christian Pirker
\\
\\ This file is part of RAFTS.
\\
\\	RAFTS is free software you can redistribute it and/or
\\	modify it under the terms of the GNU General Public License
\\	as published by the Free Software Foundation; either version 2
\\	of the License, or (at your option) any later version.
\\
\\	This program is distributed in the hope that it will be useful,
\\	but WITHOUT ANY WARRANTY; without even the implied warranty of
\\	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
\\	GNU General Public License for more details.
\\
\\	You should have received a copy of the GNU General Public License
\\	along with this program; if not, write to the Free Software
\\	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

: node_op@ ( node_addr -- op )
  node_op @ ;
: node_op! ( op node_addr -- )
  node_op ! ;

: node_slabel@ ( node_addr -- slabel )
  node_slabel @ ;
: node_slabel! ( slabel node_addr -- )
  node_slabel ! ;

: node_left@ ( node_addr -- left )
  node_left @ ;
: node_left! ( left node_addr -- )
  node_left ! ;

: node_right@ ( node_addr -- right )
  node_right @ ;
: node_right! ( right node_addr -- )
  node_right ! ;

\' node_op alias OP_LABEL
\' node_op@ alias OP_LABEL@
\' node_op! alias OP_LABEL!
\' node_slabel alias STATE_LABEL
\' node_slabel@ alias STATE_LABEL@
\' node_slabel! alias STATE_LABEL!
\' node_left alias LEFT_CHILD
\' node_left@ alias LEFT_CHILD@
\' node_left! alias LEFT_CHILD!
\' node_right alias RIGHT_CHILD
\' node_right@ alias RIGHT_CHILD@
\' node_right! alias RIGHT_CHILD!

: val ( node_addr -- node_addr )
  ;
: lval ( node_addr -- node_addr )
  LEFT_CHILD ;
: llval ( node_addr -- node_addr )
  LEFT_CHILD@ LEFT_CHILD ;
: lrval ( node_addr -- node_addr )
  LEFT_CHILD@ RIGHT_CHILD ; 
: rval ( node_addr -- node_addr )
  RIGHT_CHILD ;
: rlval ( node_addr -- node_addr )
  RIGHT_CHILD@ LEFT_CHILD ; 
: rrval ( node_addr -- node_addr ) 
  RIGHT_CHILD@ RIGHT_CHILD ;

: val@ ( node_addr -- node_addr )
  val @ ;
: lval@ ( node_addr -- node_addr )
  lval @ ;
: llval@ ( node_addr -- node_addr )
  llval @ ;
: lrval@ ( node_addr -- node_addr )
  lrval @ ;
: rval@ ( node_addr -- node_addr )
  rval @ ;
: rlval@ ( node_addr -- node_addr )
  rlval @ ;
: rrval@ ( node_addr -- node_addr ) 
  rrval @ ;

\' .\" alias burm_PANIC\" immediate

0 constant none
1 constant unary
2 constant binary

%}

%start stmt

%term I_LITS=1 I_LIT=2 I_LITF=4

/* unary operators	*/
%term I_INVERT=11
%term I_NEGATE=18 I_FNEGATE=20

/* binary operators	*/
%term I_PLUS=26 I_FPLUS=28
%term I_MINUS=98 I_FMINUS=100
%term I_TIMES=81 I_FTIMES=84
%term I_SLASH=56 DIVI=58 I_FSLASH=60
%term I_MOD=74
%term I_AND=35 I_OR=43 I_XOR=51
%term I_LSHIFT=66 LSHI=67 I_RSHIFT=90 I_SRSHIFT=91

/* fetch and store	*/
%term I_CFETCH=105 I_FETCH=106 I_FFETCH=108
%term I_CSTORE=113 I_STORE=114 I_FSTORE=116

/* compare		*/
%term I_LESS=120 I_ULESS=121 SLTF=122
%term BEQI=130 BEQF=132
%term BGEI=138 BGEU=139 BGEF=140
%term BGTI=146 BGTU=147 BGTF=148
%term BLEI=154 BLEU=155 BLEF=156
%term BLTI=162 BLTU=163 BLTF=164
%term BNEI=170 BNEF=172

%term I_REG=182

%term NOP=200

/*
addr: I_PLUS(cons, reg)		#0#	>r swap dup node_val @ r@ node_val ! [\'] asm_addr r> inst_ok
reg:  I_PLUS(cons, reg)		#1#	>r swap [\'] asm_addi r> inst_ok
reg:  I_AND(cons, reg)		#1#	>r swap [\'] asm_andi r> inst_ok
reg:  I_MINUS(reg, cons)		#1#	>r [\'] asm_addi r@ rval@ node_val @ negate r@ rval@ node_val ! r> inst_ok
reg:  I_OR(cons, reg)		#1#	>r swap [\'] asm_ori r> inst_ok
reg:  I_XOR(cons, reg)		#1#	>r swap [\'] asm_xori r> inst_ok
*/
%%

stmt: reg			#0#	2drop
addr: I_PLUS(reg, cons)		#0#	>r dup node_val @ r@ node_val ! [\'] asm_addr r> inst_ok

reg:  I_REG			#0#	
cons: I_LITS			#0#	dup inst_done
con:  I_LIT			#0#	dup inst_done
reg:  cons			#1#	node_dup >r r@ inst_notdone NIL [\'] asm_lit r> inst_ok
reg:  con			#1#	node_dup >r r@ inst_notdone NIL [\'] asm_lit r> inst_ok

reg:  I_CFETCH(addr)		#1#	>r r@ inst_notdone NIL [\'] asm_fetchc r> inst_ok
reg:  I_CFETCH(reg)		#1#	>r r@ inst_notdone NIL [\'] asm_fetchregc r> inst_ok
reg:  I_FETCH(addr)		#1#	>r r@ inst_notdone NIL [\'] asm_fetchi r> inst_ok
reg:  I_FETCH(reg)		#1#	>r r@ inst_notdone NIL [\'] asm_fetchregi r> inst_ok
stmt: I_CSTORE(reg, addr)		#1#	>r 0 r@ node_reg ! [\'] asm_storec r> inst_ok drop
stmt: I_CSTORE(reg, reg)		#1#	>r 0 r@ node_reg ! [\'] asm_storeregc r> inst_ok drop
stmt: I_STORE(reg, addr)		#1#	>r 0 r@ node_reg ! [\'] asm_storei r> inst_ok drop
stmt: I_STORE(reg, reg)		#1#	>r 0 r@ node_reg ! [\'] asm_storeregi r> inst_ok drop

reg:  I_PLUS(reg, reg)		#1#	>r [\'] asm_add r> inst_ok
reg:  I_PLUS(reg, cons)		#1#	>r [\'] asm_addi r> inst_ok
reg:  I_MINUS(reg, reg)		#1#	>r [\'] asm_sub r> inst_ok
reg: I_TIMES(reg, reg)		#1#	>r [\'] asm_mul r> inst_ok
reg: I_SLASH(reg, reg)		#1#	>r [\'] asm_div r> inst_ok
reg: I_MOD(reg, reg)		#1#	>r [\'] asm_mod r> inst_ok
reg:  I_NEGATE(reg)			#1#	>r NIL [\'] asm_neg r> inst_ok

reg:  I_AND(reg, reg)		#1#	>r [\'] asm_and r> inst_ok
reg:  I_AND(reg, cons)		#1#	>r [\'] asm_andi r> inst_ok
reg:  I_OR(reg, reg)		#1#	>r [\'] asm_or r> inst_ok
reg:  I_OR(reg, cons)		#1#	>r [\'] asm_ori r> inst_ok
reg:  I_XOR(reg, reg)		#1#	>r [\'] asm_xor r> inst_ok
reg:  I_XOR(reg, cons)		#1#	>r [\'] asm_xori r> inst_ok
reg:  I_INVERT(reg)		#1#	>r NIL [\'] asm_not r> inst_ok
reg:  I_LSHIFT(reg, reg)		#1#	>r [\'] asm_lsh r> inst_ok
reg:  LSHI(reg, reg)		#1#	>r [\'] asm_lsh r> inst_ok
reg:  I_LSHIFT(reg, cons)		#1#	>r [\'] asm_lshi r> inst_ok
reg:  LSHI(reg, cons)		#1#	>r [\'] asm_lshi r> inst_ok
reg:  I_RSHIFT(reg, reg)		#1#	>r [\'] asm_rshu r> inst_ok
reg:  I_SRSHIFT(reg, reg)		#1#	>r [\'] asm_rsh r> inst_ok
reg:  I_RSHIFT(reg, cons)		#1#	>r [\'] asm_rshui r> inst_ok
reg:  I_SRSHIFT(reg, cons)		#1#	>r [\'] asm_rshi r> inst_ok

reg:  I_LESS(reg, reg)		#1#	>r [\'] asm_slt r> inst_ok
reg:  I_LESS(reg, cons)		#1#	>r [\'] asm_slti r> inst_ok
reg:  I_ULESS(reg, reg)		#1#	>r [\'] asm_sltu r> inst_ok
reg:  I_ULESS(reg, cons)		#1#	>r [\'] asm_sltui r> inst_ok
stmt: BEQI(reg, reg)		#1#	>r [\'] asm_eq 0 r@ node_cost ! r> inst_ok drop
stmt: BGEI(reg, reg)		#1#	>r [\'] asm_eq 0 r@ node_cost ! r> inst_ok drop
stmt: BGEI(reg, cons)		#1#	>r [\'] asm_eq 0 r@ node_cost ! r> inst_ok drop
stmt: BGEI(cons, reg)		#1#	>r [\'] asm_eq 0 r@ node_cost ! r> inst_ok drop
stmt: BGEU(reg, reg)		#1#	>r [\'] asm_eq 0 r@ node_cost ! r> inst_ok drop
stmt: BGEU(reg, cons)		#1#	>r [\'] asm_eq 0 r@ node_cost ! r> inst_ok drop
stmt: BGEU(cons, reg)		#1#	>r [\'] asm_eq 0 r@ node_cost ! r> inst_ok drop
stmt: BGTI(reg, reg)		#1#	>r [\'] asm_eq 0 r@ node_cost ! r> inst_ok drop
stmt: BGTI(reg, cons)		#1#	>r [\'] asm_eq 0 r@ node_cost ! r> inst_ok drop
stmt: BGTI(cons, reg)		#1#	>r [\'] asm_eq 0 r@ node_cost ! r> inst_ok drop
stmt: BGTU(reg, reg)		#1#	>r [\'] asm_eq 0 r@ node_cost ! r> inst_ok drop
stmt: BGTU(reg, cons)		#1#	>r [\'] asm_eq 0 r@ node_cost ! r> inst_ok drop
stmt: BGTU(cons, reg)		#1#	>r [\'] asm_eq 0 r@ node_cost ! r> inst_ok drop
stmt: BLEI(reg, reg)		#1#	>r [\'] asm_eq 0 r@ node_cost ! r> inst_ok drop
stmt: BLEI(reg, cons)		#1#	>r [\'] asm_eq 0 r@ node_cost ! r> inst_ok drop
stmt: BLEI(cons, reg)		#1#	>r [\'] asm_eq 0 r@ node_cost ! r> inst_ok drop
stmt: BLEU(reg, reg)		#1#	>r [\'] asm_eq 0 r@ node_cost ! r> inst_ok drop
stmt: BLEU(reg, cons)		#1#	>r [\'] asm_eq 0 r@ node_cost ! r> inst_ok drop
stmt: BLEU(cons, reg)		#1#	>r [\'] asm_eq 0 r@ node_cost ! r> inst_ok drop
stmt: BLTI(reg, reg)		#1#	>r [\'] asm_eq 0 r@ node_cost ! r> inst_ok drop
stmt: BLTI(reg, cons)		#1#	>r [\'] asm_eq 0 r@ node_cost ! r> inst_ok drop
stmt: BLTI(cons, reg)		#1#	>r [\'] asm_eq 0 r@ node_cost ! r> inst_ok drop
stmt: BLTU(reg, reg)		#1#	>r [\'] asm_eq 0 r@ node_cost ! r> inst_ok drop
stmt: BLTU(reg, cons)		#1#	>r [\'] asm_eq 0 r@ node_cost ! r> inst_ok drop
stmt: BLTU(cons, reg)		#1#	>r [\'] asm_eq 0 r@ node_cost ! r> inst_ok drop
stmt: BNEI(reg, reg)		#1#	>r [\'] asm_eq 0 r@ node_cost ! r> inst_ok drop
stmt: BNEI(reg, cons)		#1#	>r [\'] asm_eq 0 r@ node_cost ! r> inst_ok drop
stmt: BNEI(cons, reg)		#1#	>r [\'] asm_eq 0 r@ node_cost ! r> inst_ok drop

reg:  I_FFETCH(addr)		#1#
stmt: I_FSTORE(reg, addr)		#1#	drop
reg:  I_FPLUS(reg, reg)		#1#
reg:  I_FMINUS(reg, reg)		#1#
reg:  I_FTIMES(reg, reg)		#1#
reg:  I_FSLASH(reg, reg)		#1#
reg:  I_FNEGATE(reg)			#1#

stmt: BEQF(reg, reg)		#1#	drop
stmt: BGEF(reg, reg)		#1#	drop
stmt: BGTF(reg, reg)		#1#	drop
stmt: BLEF(reg, reg)		#1#	drop
stmt: BLTF(reg, reg)		#1#	drop
stmt: BNEF(reg, reg)		#1#	drop

%%
